#include "gemt_interface.h"

// Flag: Set to true when display booted up from a menu object
bool hasBeenBootedUp = false; 

// Flag: Indicate when first menu set at start of program
bool firstMenuSet = false;

// Current state (Position) of the encoder. Max by uint8 is 255
volatile int ebState = 0; 

// Variables to mange turning bounds for all menus
int ebUpperBound = 0;
int ebLowerBound = 0;

// Updated on encoder "click" case, must reset after use 
volatile bool clicked = false; 

// Used to store the clicked value in case user turns encoder before value was processed
volatile uint8_t clickedItemNumber = 0;


// GEMT logo
const uint8_t  logo_bmp [] PROGMEM = 
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x7f, 0xf9, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x60, 0x01, 0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x60, 0x01, 0xc0, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x60, 0x01, 0xb0, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x60, 0x01, 0x98, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x7f, 0xf9, 0x8d, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x60, 0x01, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x60, 0x01, 0x82, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x60, 0x01, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xfc, 0x60, 0x01, 0x80, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xfc, 0x7f, 0xf9, 0x80, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x7f, 0xe1, 0xff, 0xcf, 0xf3, 0xff, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x3f, 0xf1, 0xff, 0xcf, 0xe3, 0xff, 0x1f, 0xfe, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0xff, 0xc7, 0xe3, 0xfe, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0xff, 0xc7, 0xe3, 0xfe, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x7f, 0xe7, 0xe7, 0xfc, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x7f, 0xe7, 0xe7, 0xfc, 0x7f, 0xe0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x3f, 0xe7, 0xe7, 0xf8, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x1f, 0xe7, 0xe7, 0xf8, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x1f, 0xe7, 0xe7, 0xf1, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x8f, 0xe7, 0xe7, 0xf1, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x8f, 0xf7, 0xc7, 0xe3, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc7, 0xf3, 0xcf, 0xe7, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc7, 0xf3, 0xcf, 0xc7, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe3, 0xf3, 0xcf, 0xcf, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf3, 0xf3, 0xcf, 0x8f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf1, 0xf3, 0xcf, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xf3, 0xcf, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xfb, 0xcf, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x7b, 0xde, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x7b, 0xde, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x3b, 0x9c, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x39, 0x9c, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x19, 0x99, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x99, 0x99, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcd, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0xb2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//========================================================================
// Menu State Handlers
//========================================================================

GEMTmenu* CurrentMenuPtr = nullptr;

void startGEMT(GEMTmenu& StartingMenu)
{
  // Skip assignment if current already equals input
  if (!firstMenuSet)
  {
    firstMenuSet = true;
    updateMenu(StartingMenu);
  }

  CurrentMenuPtr->run();
}

extern void updateMenu(GEMTmenu& NextMenu)
{
    CurrentMenuPtr = &NextMenu;
}

//========================================================================
// Encoder Handlers (Interrupt functions)
//========================================================================

// On click, the global selection variable gets updated with
// value of where it was selcted
void onEb1Encoder(EncoderButton& eb)
{
  // Reset if encoder goes past active Menu limit
  // BUG: Could cause issues to test functions if a menu only has one item
  // TODO: Setup a global var to track rotation limit that is set whenever a certain test is intiilized...
  if (eb.position() <= ebLowerBound || abs(eb.position()) >= ebUpperBound)
  {
    eb.resetPosition(0);
  }

  ebState = abs(eb.position());
  Serial.println(ebState);
  
}

void onEb1Clicked(EncoderButton& eb)
{
  // Set selection value to current state
  Serial.println("Clicked");
  clicked = true;
  clickedItemNumber = ebState; // In case user turns while
  
  ebState = 0; 
  eb.resetPosition(0); // Start at top of page
}

//========================================================================
// GEMT Base Implementations
//========================================================================

void GEMTbase::displayPrep(void)
{
    display.clearDisplay();
    display.setCursor(0, 0);
    display.setTextColor(SSD1306_WHITE, SSD1306_BLACK);
}

void GEMTbase::resetClicked(void)
{
  clicked = 0;
}


void GEMTbase::setFirstLine(String title)
{
  _firstLine = title;
}

void GEMTbase::resetMembers(void)
{
  _currIndex = 0;
}

void GEMTbase::setTurnBounds(int lower, int upper)
{
  if (ebLowerBound != lower)
  {
    ebLowerBound = lower;
  }

  if (ebUpperBound != upper)
  {
    ebUpperBound = upper;
  }
}

//========================================================================
// GEMT Menu Implementations
//========================================================================

void GEMTmenu::bootUp(void)
{
  // Do nothing
  if(hasBeenBootedUp == true)
  {
    __asm__("nop");
  }
    
  else
  {
    if(!display.begin(SSD1306_SWITCHCAPVCC, screenAddress)) 
    {
      display.println(F("SSD1306 allocation failed"));
      for(;;); // Don't proceed, loop forever
    }

    hasBeenBootedUp = true;

    // Set encode Handlers
    eb1.setEncoderHandler(onEb1Encoder);
    eb1.setClickHandler(onEb1Clicked);
    
    //attachInterrupt(digitalPinToInterrupt(19), onEb1Clicked, RISING);

    // Display logo for 2 sec
    display.clearDisplay();
    display.drawBitmap(0, 0, logo_bmp, screenWidth, screenHeight, WHITE);
    display.display();
    delay(2000);
    
    display.clearDisplay();  
    display.display();
  }
}

void GEMTmenu::addItem(String itemName, funcPtr selectionFunction)
{
  _selectionActions[_currIndex] = selectionFunction;
  _itemIds[_currIndex] = itemName;
  
  // Starts at 0, will be set to store next item if needed
  ++_currIndex;
}

void GEMTmenu::run(void)
{ 
  setTurnBounds(0, CurrentMenuPtr->numberOfMenuItems);
  if (clicked)
  {
    resetClicked(); // Reset before proceeding to function

    (*_selectionActions[clickedItemNumber])();
  
    // This works:
    // selectionActions[0] = &dummyTest; Refrencing mem address of func
    //(*selectionActions[0])(); Deref pointer to execute function
    // ==  dummyTest()
  }
  
  //Display the previous Menu state
  else
  {
    char buffer[50]; // init buffer to hold expected string size
    
    // Setup
    eb1.update();
    displayPrep();
    
    display.println(_firstLine);
    // Display all current Menu options
    for (size_t i = 0; i < (numberOfMenuItems); ++i)
    {
      // Highlight line if user is hovering over it
      if (ebState == i)
      {
        display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
      }
      else 
      {
        display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
      }
    
      // NOTE: Need c_str() since Arduino String is not a c_string and has different delimiter
      sprintf(buffer, "%s", _itemIds[i].c_str());

      display.println(buffer);
    }
    
    display.display();
  }
}

//========================================================================
// GEMT Test Implementations
//========================================================================

void GEMTtest::_resetMembers(void)
{
  testingComplete = false;
  _currIndex = 0;

  for(int i = 0; i < maxItems; ++i)
  {
    _infoMsgs[i] = "";
    _testFeedbackMsgs[i] = "";
  } 

}

void GEMTtest::setInfoMsgLine(String msg)
{
  _infoMsgs[_currIndex] = msg;
  ++_currIndex;
}

bool GEMTtest::showInfoScreen(void)
{
  bool proceed = false;
  
  setTurnBounds(0, 2);
  const String confirmOptions[2] = {"OK", "Back"};
  
  while(!clicked)
  {
      eb1.update();
      displayPrep();

      // Title
      display.println(_firstLine);

      // Stored msgs, will print blank lines if none available
      for(int i = 0; i < maxItems; ++i)
      {
        display.println(_infoMsgs[i]);
      }

      // Confirm selection options
      for (int i = 0; i < 2; i++)
      {
        // Highlight line if user is hovering over it
        // Don't highlight the bar though
        if (ebState == i)
        {
          display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
        }
        else 
        {
          display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
        }

        // Positional Printing
        if (i == 0)
        {
          display.setCursor(0, 56);
          display.print(confirmOptions[i]);
        }
        else if (i == 1)
        {
          display.setCursor(64, 56);
          display.print(confirmOptions[i]);
        }   
      }

      display.display();
  }

  resetClicked();
  _resetMembers();

  // If user clicked on OK
  if(clickedItemNumber == 0)
  {
    proceed = true;
  }

  return proceed;
}

void GEMTtest::setStaticTestFeedbackLine(String msg)
{
  _testFeedbackMsgs[_currIndex] = msg;
  ++_currIndex;
}

void GEMTtest::showStaticTestFeedback(void)
{
  eb1.update();
  displayPrep();

  display.println(_firstLine);
  for(int i = 0; i < maxItems; ++i)
  {
    display.println(_testFeedbackMsgs[i]);
  }

  // Force "Done" to be printed in last line, lower corner
  display.setCursor(0, 56);
  display.print("Done");


  display.display();
  // We dont want to reset clicked in this case, that ways it carries over to showStaticTestScreen

  _currIndex = 0;
}

void GEMTtest::showStaticTestScreen(funcPtr moduleTest)
{
  setTurnBounds(0, 1);
  //attachInterrupt(digitalPinToInterrupt(19), onEb1Clicked, LOW);

  while(!clicked)
  {
    // Run test
    if(testingComplete == false)
    {
      (*moduleTest)();
    }

    eb1.update();
    displayPrep();

    display.println(_firstLine);
    for(int i = 0; i < maxItems; ++i)
    {
      display.println(_testFeedbackMsgs[i]);
    }

    display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
    // Force "Done" to be printed in last line, lower corner
    display.setCursor(0, 56);
    display.print("Done");

    display.display();
  }

  _resetMembers();
  resetClicked();
}

// TODO: Implement feedback line
void GEMTtest::showInteractiveTestScreen(funcPtr writeFunction, String unitID, int lowerBound, int upperBound)
{
  // Screen click options:
  //   0 - Set value
  //   1 - Run
  //   2 - Done

   // TODO: try changing this to String...
  char buffer[20]; // init buffer to hold expected string size

  // Only 3 selecteable options in test screen
  // We also "hard-code" since we update upper bound on click
  setTurnBounds(0, 3);
  while(true)
  {
    if(clicked)
    {
      resetClicked();

      if(clickedItemNumber == 0)
      {
        // Update bound so user can scroll up to desired value
        setTurnBounds(lowerBound, upperBound);
        ebState = interactiveValue[0]; // So we start at previously saved angle

        // TODO: Drops back down to 0 when clicking on it again
        display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);
        while(!clicked)
        {
          interactiveValue[0] = ebState;

          eb1.update();
          displayPrep();

          display.println(_firstLine);

          display.setCursor(0, 12);
          display.print(unitID);

          display.setCursor(64, 12);
          display.print(String(interactiveValue[0]));

          display.setCursor(0, 56);
          display.println("Run");

          display.setCursor(64, 56);
          display.println("Done");

          display.display();
        }

        resetClicked();
      }
      else if (clickedItemNumber == 1)
      {
        (*writeFunction)(); // It'll get updated with current value
      }
      else if (clickedItemNumber == 2)
      {
        return;
      }
    }

    String displayText[3] = {String(interactiveValue[0]), "Run", "Done"};
    setTurnBounds(0, 3);

    eb1.update();
    displayPrep();

    display.println(_firstLine);
    
    display.setCursor(0, 12);
    display.print(unitID);

    // Probably could do this better but the for loop lets us highlight shit, soooo
    for (int i = 0; i < 3; ++i)
    {
      // Highlight line if user is hovering over it
      // Dont want to highlight unit id though...
      if (ebState == i)
      {
        display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
      }
      else 
      {
        display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
      }

      // NOTE: Need c_str() since Arduino String is not a c_string and has different delimiter
      sprintf(buffer, "%s", displayText[i].c_str());

      // Positional printing:
      if (i == 0)
      {
        display.setCursor(64, 12);
        display.print(buffer);
      }
      else if (i == 1)
      {
        display.setCursor(0, 56);
        display.print(buffer);
      }
      else if (i == 2)
      {
        display.setCursor(64, 56);
        display.print(buffer);
      }   
    }

    display.display();
  }
}
