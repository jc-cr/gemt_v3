#include "gemt_interface.h"


// Flag: Set to true when display booted up from a menu object
bool hasBeenBootedUp = false; 

bool firstMenuSet = false;

// Current state (Position) of the encoder. Max by uint8 is 255
volatile int ebState = 0; 

// Updated on encoder "click" case, must reset after use 
volatile bool clicked = false; 

volatile uint8_t clickedItemNumber = 0;

const uint8_t  logo_bmp [] PROGMEM = 
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x7f, 0xf9, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x60, 0x01, 0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x60, 0x01, 0xc0, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x60, 0x01, 0xb0, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x60, 0x01, 0x98, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x7f, 0xf9, 0x8d, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x60, 0x01, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x60, 0x01, 0x82, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x60, 0x01, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xfc, 0x60, 0x01, 0x80, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x04, 0x60, 0x01, 0x80, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xfc, 0x7f, 0xf9, 0x80, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x7f, 0xe1, 0xff, 0xcf, 0xf3, 0xff, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x3f, 0xf1, 0xff, 0xcf, 0xe3, 0xff, 0x1f, 0xfe, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0xff, 0xc7, 0xe3, 0xfe, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0xff, 0xc7, 0xe3, 0xfe, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x7f, 0xe7, 0xe7, 0xfc, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x7f, 0xe7, 0xe7, 0xfc, 0x7f, 0xe0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x3f, 0xe7, 0xe7, 0xf8, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x1f, 0xe7, 0xe7, 0xf8, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x1f, 0xe7, 0xe7, 0xf1, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x8f, 0xe7, 0xe7, 0xf1, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x8f, 0xf7, 0xc7, 0xe3, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc7, 0xf3, 0xcf, 0xe7, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc7, 0xf3, 0xcf, 0xc7, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe3, 0xf3, 0xcf, 0xcf, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf3, 0xf3, 0xcf, 0x8f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf1, 0xf3, 0xcf, 0x9f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xf3, 0xcf, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xfb, 0xcf, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x7b, 0xde, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x7b, 0xde, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x3b, 0x9c, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x39, 0x9c, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x19, 0x99, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x99, 0x99, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcd, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0xb2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

int ebUpperBound = 0;

//========================================================================
// Menu State Handlers
//========================================================================

GEMTmenu* CurrentMenuPtr = nullptr;

void startGEMT(GEMTmenu& StartingMenu)
{
  // Skip assignment if current already equals input
  if (!firstMenuSet)
  {
    firstMenuSet = true;
    updateMenu(StartingMenu);
  }

  CurrentMenuPtr->run();
}

extern void updateMenu(GEMTmenu& NextMenu)
{
  
    CurrentMenuPtr = &NextMenu;
    ebUpperBound = CurrentMenuPtr->numberOfMenuItems;
}

//========================================================================
// Encoder Handlers (Interrupt functions)
//========================================================================

// On click, the global selection variable gets updated with
// value of where it was selcted
void onEb1Encoder(EncoderButton& eb)
{
  // Reset if encoder goes past active Menu limit
  // BUG: Could cause issues to test functions if a menu only has one item
  // TODO: Setup a global var to track rotation limit that is set whenever a certain test is intiilized...
  if (abs(eb.position()) >= ebUpperBound)
  {
    eb.resetPosition(0);
  }

  ebState = abs(eb.position());
  
}

void onEb1Clicked(EncoderButton& eb)
{
  // Set selection value to current state
  clicked = true;
  clickedItemNumber = ebState; // In case user turns while
  ebState = 0; // Start at top of page
  eb.resetPosition(0);
}

//========================================================================
// GEMT Base Implementations
//========================================================================

void GEMTbase::displayPrep(void)
{
    display.clearDisplay();
    display.setCursor(0, 0);
    display.setTextColor(SSD1306_WHITE, SSD1306_BLACK);
}

void GEMTbase::resetClicked(void)
{
  clicked = 0;
}


void GEMTbase::setFirstLine(String title)
{
  _firstLine = title;
}

void GEMTbase::resetMembers(void)
{
  _currIndex = 0;
}

//========================================================================
// GEMT Menu Implementations
//========================================================================

void GEMTmenu::bootUp(void)
{
  // Do nothing
  if(hasBeenBootedUp == true)
  {
    __asm__("nop");
  }
    
  else
  {
    if(!display.begin(SSD1306_SWITCHCAPVCC, screenAddress)) 
    {
      display.println(F("SSD1306 allocation failed"));
      for(;;); // Don't proceed, loop forever
    }

    hasBeenBootedUp = true;

    // Set encode Handlers
    eb1.setEncoderHandler(onEb1Encoder);
    eb1.setClickHandler(onEb1Clicked);
    
    // Display logo for 2 sec
    display.clearDisplay();
    display.drawBitmap(0, 0, logo_bmp, screenWidth, screenHeight, WHITE);
    display.display();
    delay(2000);
    
    display.clearDisplay();  
    display.display();
  }
}

void GEMTmenu::addItem(String itemName, funcPtr selectionFunction)
{
  _selectionActions[_currIndex] = selectionFunction;
  _itemIds[_currIndex] = itemName;
  
  // Starts at 0, will be set to store next item if needed
  ++_currIndex;
}

void GEMTmenu::run(void)
{
  // Condition for executing users selections based on 'clicked' bool
  
  if (clicked)
  {
    resetClicked(); // Reset before proceeding to function

    (*_selectionActions[clickedItemNumber])();
  
    // This works:
    // selectionActions[0] = &dummyTest; Refrencing mem address of func
    //(*selectionActions[0])(); Deref pointer to execute function
    // ==  dummyTest()
  }
  
  //Display the previous Menu state
  else
  {
    char buffer[50]; // init buffer to hold expected string size
    
    // Setup
    eb1.update();
    displayPrep();
    
    display.println(_firstLine);
    // Display all current Menu options
    for (size_t i = 0; i < (numberOfMenuItems); ++i)
    {
      // Highlight line if user is hovering over it
      if (ebState == i)
      {
        display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
      }
      else 
      {
        display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
      }
    
      // NOTE: Need c_str() since Arduino String is not a c_string and has different delimiter
      sprintf(buffer, "%s", _itemIds[i].c_str());

      display.println(buffer);
    }
    
    display.display();
  }
}

//========================================================================
// GEMT Test Implementations
//========================================================================

void GEMTtest::resetMembers(void)
{
  _currIndex = 0;

  for(int i = 0; i < maxItems; ++i)
  {
    _testFeedbackMsgs[i] = "";
  } 

}

void GEMTtest::setInfoMsgLine(String msg)
{
  _infoMsgs[_currIndex] = msg;
  ++_currIndex;
}

bool GEMTtest::showInfoScreen(void)
{
  bool proceed = false;

  const String confirmOptions[3] = {"OK", "|", "Back"};
  ebUpperBound = 3;

  while(!clicked)
  {
      eb1.update();
      displayPrep();

      // Title
      display.println(_firstLine);

      // Stored msgs, will print blank if none available
      for(int i = 0; i < maxItems; ++i)
      {
        display.println(_infoMsgs[i]);
      }

      // Confirm selection options
      for (size_t i = 0; i < 3; i++)
      {
        // Highlight line if user is hovering over it
        // Don't highlight the bar though
        if (ebState == i && i != 1)
        {
          display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
        }
        else 
        {
          display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
        }
        
        display.print(confirmOptions[i]);
      }

      display.display();
  }

    resetClicked();

    // If user clicked on OK
    if(clickedItemNumber == 0)
    {
      proceed = true;
    }

    return proceed;
}

void GEMTtest::showStaticTestFeedback(String msg)
{
  eb1.update();
  displayPrep();

  _testFeedbackMsgs[0] = msg;
  
  display.println(_firstLine);
  for(int i = 0; i < maxItems; ++i)
  {
    display.println(_testFeedbackMsgs[i]);
  }

  display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
  display.println("Done");

  display.display();
  delay(2000);
}

void GEMTtest::showStaticTestScreen(funcPtr moduleTest)
{
  (*moduleTest)();
  while(!clicked)
  {
    eb1.update();
    displayPrep();

    display.println(_firstLine);
    for(int i = 0; i < maxItems; ++i)
    {
      display.println(_testFeedbackMsgs[i]);
    }
    display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
    display.println("Done");
    display.display();
  }
}

void GEMTtest::showInteractiveTestScreen(funcPtr writeFunction, String unitID, int lowerBound, int upperBound)
{
  // Screen click options:
  //   0 - Set value
  //   1 - Run
  //   2 - Done

  // TODO: set lower bound to check, right now just going off max because Im lazy...
  ebUpperBound = 3;
  // TODO: try changing this to String...
  char buffer[20]; // init buffer to hold expected string size

  while(true)
  {
    if(clicked)
    {
      resetClicked();

      if(clickedItemNumber == 0)
      {
        ebUpperBound = upperBound;
        ebState = interactiveValue[0]; // So we start at previously saved angle

        // TODO: Drops back down to 0 when clicking on it again
        display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);
        while(!clicked)
        {
          interactiveValue[0] = ebState;

          eb1.update();
          displayPrep();

          display.println(_firstLine);

          display.setCursor(0, 12);
          display.print(unitID);

          display.setCursor(64, 12);
          display.print(String(interactiveValue[0]));

          display.setCursor(0, 56);
          display.println("Run");

          display.setCursor(64, 56);
          display.println("Done");

          display.display();
        }

        resetClicked();
      }
      else if (clickedItemNumber == 1)
      {
        (*writeFunction)(); // It'll get updated with current value
      }
      else if (clickedItemNumber == 2)
      {
        return;
      }

      ebUpperBound = 3;
    }

    String displayText[3] = {String(interactiveValue[0]), "Run", "Done"};

    eb1.update();
    displayPrep();

    display.println(_firstLine);
    
    display.setCursor(0, 12);
    display.print(unitID);

    // Probably could do this better but the for loop lets us highlight shit, soooo
    for (size_t i = 0; i < 3; ++i)
    {
      // Highlight line if user is hovering over it
      // Dont want to highlight unit id though...
      if (ebState == i)
      {
        display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Draw 'inverse' text
      }
      else 
      {
        display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); 
      }

      // NOTE: Need c_str() since Arduino String is not a c_string and has different delimiter
      sprintf(buffer, "%s", displayText[i].c_str());

      // Positional printing:
      if (i == 0)
      {
        display.setCursor(64, 12);
        display.print(buffer);
      }
      else if (i == 1)
      {
        display.setCursor(0, 56);
        display.print(buffer);
      }
      else if (i == 2)
      {
        display.setCursor(64, 56);
        display.print(buffer);
      }   
    }

    display.display();
  }
  
}


void GEMTtest::showInteractiveTestScreen(funcPtr writeFunction, String unitID, int lowerBound, int upperBound, String feedbackMsg)
{
  
}

// Display section showing 
// TODO: will need to overide encoder turn limit
//    could make bounds global? 
void GEMTtest::updateIntereactiveValue(void)
{ 
  
}







